
    private ManualResetEvent _shutdownEvent = new ManualResetEvent(false);
    private Thread _thread;

    protected override void OnStart(string[] args) {
          // create our threadstart object to wrap our delegate method
          ThreadStart ts = new ThreadStart( this.ServiceMQTT );

          // create the manual reset event and
          // set it to an initial state of unsignaled
          _shutdownEvent = new ManualResetEvent(false);

          // create the worker thread
          _thread = new Thread( ts );

          // go ahead and start the worker thread
          _thread.Start();

          // call the base class so it has a chance
          // to perform any work it needs to
          base.OnStart( args );
    }

    protected void ServiceMQTT() {        
         // infinite loop
        while (!_shutdownEvent.WaitOne(0))
        {
               
          if ( !mqttPublisherClient ) {
            var options = new ManagedMqttClientOptionsBuilder()
             .WithAutoReconnectDelay(TimeSpan.FromSeconds(5))
             .WithClientOptions(new MqttClientOptionsBuilder()
                 .WithClientId(customClientId)
                 .WithWebSocketServer(mqttServAddress)
                 .WithCredentials(username, password)
                 .Build())
             .Build();

            mqttPublisherClient = factory.CreateManagedMqttClient(new MqttNetLogger(loggerName));
            MqttNetGlobalLogger.LogMessagePublished += (s, e) =>
            {
              var trace = $">> [{e.TraceMessage.Timestamp:O}] [{e.TraceMessage.ThreadId}] [{e.TraceMessage.Source}] [{e.TraceMessage.Level}]: {e.TraceMessage.Message}";
              if (e.TraceMessage.Exception != null)
              {
                trace += Environment.NewLine + e.TraceMessage.Exception.ToString();
              }

              Debug.WriteLine('\x2' + trace);
            };

            // await mqttPublisherClient.StartAsync(options);
            await mqttPublisherClient.StartAsync(options);
            Console.WriteLine("mqtt client started\n");

            mqttPublisherClient.Disconnected += (s, e) =>
            {
              Console.WriteLine("### DISCONNECTED FROM SERVER ###");
            };

            mqttPublisherClient.Connected += (s, e) =>
            {
              Console.WriteLine("### CONNECTED WITH SERVER ###");
            };

            mqttPublisherClient.ApplicationMessageProcessed += (s, e) =>
            {     
              if (e.HasSucceeded)
              {
                Console.WriteLine("message successfully published!");
              }
              else
              {
                Console.WriteLine("message failed to publish!");
              }
            };     
          }
          else {
            // Replace the Sleep() call with the work you need to do     
            // Thread.Sleep(1000);
          }

        }
    }


    /// Stop this service.
    /// </SUMMARY>
    protected override void OnStop() {
        // signal the event to shutdown
        _shutdownEvent.Set();

        // wait for the thread to stop giving it 10 seconds
        _thread.Join(10000);

        // call the base class 
        base.OnStop();
    }